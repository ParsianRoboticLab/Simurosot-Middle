// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages_parsian_simurosot_debugs.proto

#ifndef PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
#define PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto 

namespace protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
class Cir2D;
class Cir2DDefaultTypeInternal;
extern Cir2DDefaultTypeInternal _Cir2D_default_instance_;
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class Draws;
class DrawsDefaultTypeInternal;
extern DrawsDefaultTypeInternal _Draws_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class Logs;
class LogsDefaultTypeInternal;
extern LogsDefaultTypeInternal _Logs_default_instance_;
class Pol2D;
class Pol2DDefaultTypeInternal;
extern Pol2DDefaultTypeInternal _Pol2D_default_instance_;
class Rec2D;
class Rec2DDefaultTypeInternal;
extern Rec2DDefaultTypeInternal _Rec2D_default_instance_;
class Seg2D;
class Seg2DDefaultTypeInternal;
extern Seg2DDefaultTypeInternal _Seg2D_default_instance_;
class Tex2D;
class Tex2DDefaultTypeInternal;
extern Tex2DDefaultTypeInternal _Tex2D_default_instance_;
class Vec2;
class Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec2D;
class Vec2DDefaultTypeInternal;
extern Vec2DDefaultTypeInternal _Vec2D_default_instance_;
namespace google {
namespace protobuf {
template<> ::Cir2D* Arena::CreateMaybeMessage<::Cir2D>(Arena*);
template<> ::Color* Arena::CreateMaybeMessage<::Color>(Arena*);
template<> ::Draws* Arena::CreateMaybeMessage<::Draws>(Arena*);
template<> ::Log* Arena::CreateMaybeMessage<::Log>(Arena*);
template<> ::Logs* Arena::CreateMaybeMessage<::Logs>(Arena*);
template<> ::Pol2D* Arena::CreateMaybeMessage<::Pol2D>(Arena*);
template<> ::Rec2D* Arena::CreateMaybeMessage<::Rec2D>(Arena*);
template<> ::Seg2D* Arena::CreateMaybeMessage<::Seg2D>(Arena*);
template<> ::Tex2D* Arena::CreateMaybeMessage<::Tex2D>(Arena*);
template<> ::Vec2* Arena::CreateMaybeMessage<::Vec2>(Arena*);
template<> ::Vec2D* Arena::CreateMaybeMessage<::Vec2D>(Arena*);
}  // namespace protobuf
}  // namespace google

enum LogLevel {
  LL_DEBUG = 0,
  LL_INFO = 1,
  LL_WARN = 2,
  LL_ERROR = 3,
  LL_FATAL = 4,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LogLevel_IsValid(int value);
const LogLevel LogLevel_MIN = LL_DEBUG;
const LogLevel LogLevel_MAX = LL_FATAL;
const int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogLevel_descriptor();
inline const ::std::string& LogLevel_Name(LogLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogLevel_descriptor(), value);
}
inline bool LogLevel_Parse(
    const ::std::string& name, LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
// ===================================================================

class Color : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Color) */ {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Color* other);
  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(NULL);
  }

  Color* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float r = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // float g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // float a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  float a() const;
  void set_a(float value);

  // @@protoc_insertion_point(class_scope:Color)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vec2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vec2) */ {
 public:
  Vec2();
  virtual ~Vec2();

  Vec2(const Vec2& from);

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(Vec2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Vec2* other);
  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec2* New() const final {
    return CreateMaybeMessage<Vec2>(NULL);
  }

  Vec2* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:Vec2)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vec2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vec2D) */ {
 public:
  Vec2D();
  virtual ~Vec2D();

  Vec2D(const Vec2D& from);

  inline Vec2D& operator=(const Vec2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec2D(Vec2D&& from) noexcept
    : Vec2D() {
    *this = ::std::move(from);
  }

  inline Vec2D& operator=(Vec2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2D* internal_default_instance() {
    return reinterpret_cast<const Vec2D*>(
               &_Vec2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Vec2D* other);
  friend void swap(Vec2D& a, Vec2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec2D* New() const final {
    return CreateMaybeMessage<Vec2D>(NULL);
  }

  Vec2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec2D& from);
  void MergeFrom(const Vec2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:Vec2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Color* color_;
  float x_;
  float y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cir2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Cir2D) */ {
 public:
  Cir2D();
  virtual ~Cir2D();

  Cir2D(const Cir2D& from);

  inline Cir2D& operator=(const Cir2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cir2D(Cir2D&& from) noexcept
    : Cir2D() {
    *this = ::std::move(from);
  }

  inline Cir2D& operator=(Cir2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Cir2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cir2D* internal_default_instance() {
    return reinterpret_cast<const Cir2D*>(
               &_Cir2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Cir2D* other);
  friend void swap(Cir2D& a, Cir2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cir2D* New() const final {
    return CreateMaybeMessage<Cir2D>(NULL);
  }

  Cir2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cir2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Cir2D& from);
  void MergeFrom(const Cir2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cir2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Vec2 center = 1;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  private:
  const ::Vec2& _internal_center() const;
  public:
  const ::Vec2& center() const;
  ::Vec2* release_center();
  ::Vec2* mutable_center();
  void set_allocated_center(::Vec2* center);

  // .Color color = 6;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 6;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // float startAngle = 2;
  void clear_startangle();
  static const int kStartAngleFieldNumber = 2;
  float startangle() const;
  void set_startangle(float value);

  // float endAngle = 3;
  void clear_endangle();
  static const int kEndAngleFieldNumber = 3;
  float endangle() const;
  void set_endangle(float value);

  // float radius = 4;
  void clear_radius();
  static const int kRadiusFieldNumber = 4;
  float radius() const;
  void set_radius(float value);

  // bool fill = 5;
  void clear_fill();
  static const int kFillFieldNumber = 5;
  bool fill() const;
  void set_fill(bool value);

  // @@protoc_insertion_point(class_scope:Cir2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* center_;
  ::Color* color_;
  float startangle_;
  float endangle_;
  float radius_;
  bool fill_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Seg2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Seg2D) */ {
 public:
  Seg2D();
  virtual ~Seg2D();

  Seg2D(const Seg2D& from);

  inline Seg2D& operator=(const Seg2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Seg2D(Seg2D&& from) noexcept
    : Seg2D() {
    *this = ::std::move(from);
  }

  inline Seg2D& operator=(Seg2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Seg2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Seg2D* internal_default_instance() {
    return reinterpret_cast<const Seg2D*>(
               &_Seg2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Seg2D* other);
  friend void swap(Seg2D& a, Seg2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Seg2D* New() const final {
    return CreateMaybeMessage<Seg2D>(NULL);
  }

  Seg2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Seg2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Seg2D& from);
  void MergeFrom(const Seg2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Seg2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Vec2 origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  private:
  const ::Vec2& _internal_origin() const;
  public:
  const ::Vec2& origin() const;
  ::Vec2* release_origin();
  ::Vec2* mutable_origin();
  void set_allocated_origin(::Vec2* origin);

  // .Vec2 terminal = 2;
  bool has_terminal() const;
  void clear_terminal();
  static const int kTerminalFieldNumber = 2;
  private:
  const ::Vec2& _internal_terminal() const;
  public:
  const ::Vec2& terminal() const;
  ::Vec2* release_terminal();
  ::Vec2* mutable_terminal();
  void set_allocated_terminal(::Vec2* terminal);

  // .Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // @@protoc_insertion_point(class_scope:Seg2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* origin_;
  ::Vec2* terminal_;
  ::Color* color_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rec2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rec2D) */ {
 public:
  Rec2D();
  virtual ~Rec2D();

  Rec2D(const Rec2D& from);

  inline Rec2D& operator=(const Rec2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rec2D(Rec2D&& from) noexcept
    : Rec2D() {
    *this = ::std::move(from);
  }

  inline Rec2D& operator=(Rec2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rec2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rec2D* internal_default_instance() {
    return reinterpret_cast<const Rec2D*>(
               &_Rec2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Rec2D* other);
  friend void swap(Rec2D& a, Rec2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rec2D* New() const final {
    return CreateMaybeMessage<Rec2D>(NULL);
  }

  Rec2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rec2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rec2D& from);
  void MergeFrom(const Rec2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rec2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Vec2 topLeft = 1;
  bool has_topleft() const;
  void clear_topleft();
  static const int kTopLeftFieldNumber = 1;
  private:
  const ::Vec2& _internal_topleft() const;
  public:
  const ::Vec2& topleft() const;
  ::Vec2* release_topleft();
  ::Vec2* mutable_topleft();
  void set_allocated_topleft(::Vec2* topleft);

  // .Vec2 BotRight = 2;
  bool has_botright() const;
  void clear_botright();
  static const int kBotRightFieldNumber = 2;
  private:
  const ::Vec2& _internal_botright() const;
  public:
  const ::Vec2& botright() const;
  ::Vec2* release_botright();
  ::Vec2* mutable_botright();
  void set_allocated_botright(::Vec2* botright);

  // .Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // bool fill = 4;
  void clear_fill();
  static const int kFillFieldNumber = 4;
  bool fill() const;
  void set_fill(bool value);

  // @@protoc_insertion_point(class_scope:Rec2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Vec2* topleft_;
  ::Vec2* botright_;
  ::Color* color_;
  bool fill_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tex2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Tex2D) */ {
 public:
  Tex2D();
  virtual ~Tex2D();

  Tex2D(const Tex2D& from);

  inline Tex2D& operator=(const Tex2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tex2D(Tex2D&& from) noexcept
    : Tex2D() {
    *this = ::std::move(from);
  }

  inline Tex2D& operator=(Tex2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tex2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tex2D* internal_default_instance() {
    return reinterpret_cast<const Tex2D*>(
               &_Tex2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Tex2D* other);
  friend void swap(Tex2D& a, Tex2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tex2D* New() const final {
    return CreateMaybeMessage<Tex2D>(NULL);
  }

  Tex2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tex2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tex2D& from);
  void MergeFrom(const Tex2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tex2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 4;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .Vec2 pos = 1;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 1;
  private:
  const ::Vec2& _internal_pos() const;
  public:
  const ::Vec2& pos() const;
  ::Vec2* release_pos();
  ::Vec2* mutable_pos();
  void set_allocated_pos(::Vec2* pos);

  // .Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // float size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  float size() const;
  void set_size(float value);

  // @@protoc_insertion_point(class_scope:Tex2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::Vec2* pos_;
  ::Color* color_;
  float size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pol2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pol2D) */ {
 public:
  Pol2D();
  virtual ~Pol2D();

  Pol2D(const Pol2D& from);

  inline Pol2D& operator=(const Pol2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pol2D(Pol2D&& from) noexcept
    : Pol2D() {
    *this = ::std::move(from);
  }

  inline Pol2D& operator=(Pol2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pol2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pol2D* internal_default_instance() {
    return reinterpret_cast<const Pol2D*>(
               &_Pol2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Pol2D* other);
  friend void swap(Pol2D& a, Pol2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pol2D* New() const final {
    return CreateMaybeMessage<Pol2D>(NULL);
  }

  Pol2D* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pol2D>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pol2D& from);
  void MergeFrom(const Pol2D& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pol2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Vec2 vectors = 1;
  int vectors_size() const;
  void clear_vectors();
  static const int kVectorsFieldNumber = 1;
  ::Vec2* mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField< ::Vec2 >*
      mutable_vectors();
  const ::Vec2& vectors(int index) const;
  ::Vec2* add_vectors();
  const ::google::protobuf::RepeatedPtrField< ::Vec2 >&
      vectors() const;

  // .Color color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  private:
  const ::Color& _internal_color() const;
  public:
  const ::Color& color() const;
  ::Color* release_color();
  ::Color* mutable_color();
  void set_allocated_color(::Color* color);

  // bool fill = 3;
  void clear_fill();
  static const int kFillFieldNumber = 3;
  bool fill() const;
  void set_fill(bool value);

  // @@protoc_insertion_point(class_scope:Pol2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Vec2 > vectors_;
  ::Color* color_;
  bool fill_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Draws : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Draws) */ {
 public:
  Draws();
  virtual ~Draws();

  Draws(const Draws& from);

  inline Draws& operator=(const Draws& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Draws(Draws&& from) noexcept
    : Draws() {
    *this = ::std::move(from);
  }

  inline Draws& operator=(Draws&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Draws& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Draws* internal_default_instance() {
    return reinterpret_cast<const Draws*>(
               &_Draws_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Draws* other);
  friend void swap(Draws& a, Draws& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Draws* New() const final {
    return CreateMaybeMessage<Draws>(NULL);
  }

  Draws* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Draws>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Draws& from);
  void MergeFrom(const Draws& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Draws* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Vec2D vectors = 1;
  int vectors_size() const;
  void clear_vectors();
  static const int kVectorsFieldNumber = 1;
  ::Vec2D* mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField< ::Vec2D >*
      mutable_vectors();
  const ::Vec2D& vectors(int index) const;
  ::Vec2D* add_vectors();
  const ::google::protobuf::RepeatedPtrField< ::Vec2D >&
      vectors() const;

  // repeated .Cir2D circles = 2;
  int circles_size() const;
  void clear_circles();
  static const int kCirclesFieldNumber = 2;
  ::Cir2D* mutable_circles(int index);
  ::google::protobuf::RepeatedPtrField< ::Cir2D >*
      mutable_circles();
  const ::Cir2D& circles(int index) const;
  ::Cir2D* add_circles();
  const ::google::protobuf::RepeatedPtrField< ::Cir2D >&
      circles() const;

  // repeated .Seg2D segments = 3;
  int segments_size() const;
  void clear_segments();
  static const int kSegmentsFieldNumber = 3;
  ::Seg2D* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField< ::Seg2D >*
      mutable_segments();
  const ::Seg2D& segments(int index) const;
  ::Seg2D* add_segments();
  const ::google::protobuf::RepeatedPtrField< ::Seg2D >&
      segments() const;

  // repeated .Rec2D rects = 4;
  int rects_size() const;
  void clear_rects();
  static const int kRectsFieldNumber = 4;
  ::Rec2D* mutable_rects(int index);
  ::google::protobuf::RepeatedPtrField< ::Rec2D >*
      mutable_rects();
  const ::Rec2D& rects(int index) const;
  ::Rec2D* add_rects();
  const ::google::protobuf::RepeatedPtrField< ::Rec2D >&
      rects() const;

  // repeated .Pol2D polygons = 5;
  int polygons_size() const;
  void clear_polygons();
  static const int kPolygonsFieldNumber = 5;
  ::Pol2D* mutable_polygons(int index);
  ::google::protobuf::RepeatedPtrField< ::Pol2D >*
      mutable_polygons();
  const ::Pol2D& polygons(int index) const;
  ::Pol2D* add_polygons();
  const ::google::protobuf::RepeatedPtrField< ::Pol2D >&
      polygons() const;

  // repeated .Tex2D texts = 6;
  int texts_size() const;
  void clear_texts();
  static const int kTextsFieldNumber = 6;
  ::Tex2D* mutable_texts(int index);
  ::google::protobuf::RepeatedPtrField< ::Tex2D >*
      mutable_texts();
  const ::Tex2D& texts(int index) const;
  ::Tex2D* add_texts();
  const ::google::protobuf::RepeatedPtrField< ::Tex2D >&
      texts() const;

  // @@protoc_insertion_point(class_scope:Draws)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Vec2D > vectors_;
  ::google::protobuf::RepeatedPtrField< ::Cir2D > circles_;
  ::google::protobuf::RepeatedPtrField< ::Seg2D > segments_;
  ::google::protobuf::RepeatedPtrField< ::Rec2D > rects_;
  ::google::protobuf::RepeatedPtrField< ::Pol2D > polygons_;
  ::google::protobuf::RepeatedPtrField< ::Tex2D > texts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(Log&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Log* other);
  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const final {
    return CreateMaybeMessage<Log>(NULL);
  }

  Log* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Log>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // string file = 3;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // string function = 4;
  void clear_function();
  static const int kFunctionFieldNumber = 4;
  const ::std::string& function() const;
  void set_function(const ::std::string& value);
  #if LANG_CXX11
  void set_function(::std::string&& value);
  #endif
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  ::std::string* mutable_function();
  ::std::string* release_function();
  void set_allocated_function(::std::string* function);

  // string line = 5;
  void clear_line();
  static const int kLineFieldNumber = 5;
  const ::std::string& line() const;
  void set_line(const ::std::string& value);
  #if LANG_CXX11
  void set_line(::std::string&& value);
  #endif
  void set_line(const char* value);
  void set_line(const char* value, size_t size);
  ::std::string* mutable_line();
  ::std::string* release_line();
  void set_allocated_line(::std::string* line);

  // .LogLevel level = 1;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::LogLevel level() const;
  void set_level(::LogLevel value);

  // @@protoc_insertion_point(class_scope:Log)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::internal::ArenaStringPtr function_;
  ::google::protobuf::internal::ArenaStringPtr line_;
  int level_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Logs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Logs) */ {
 public:
  Logs();
  virtual ~Logs();

  Logs(const Logs& from);

  inline Logs& operator=(const Logs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Logs(Logs&& from) noexcept
    : Logs() {
    *this = ::std::move(from);
  }

  inline Logs& operator=(Logs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Logs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logs* internal_default_instance() {
    return reinterpret_cast<const Logs*>(
               &_Logs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Logs* other);
  friend void swap(Logs& a, Logs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Logs* New() const final {
    return CreateMaybeMessage<Logs>(NULL);
  }

  Logs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Logs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Logs& from);
  void MergeFrom(const Logs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Log msgs = 1;
  int msgs_size() const;
  void clear_msgs();
  static const int kMsgsFieldNumber = 1;
  ::Log* mutable_msgs(int index);
  ::google::protobuf::RepeatedPtrField< ::Log >*
      mutable_msgs();
  const ::Log& msgs(int index) const;
  ::Log* add_msgs();
  const ::google::protobuf::RepeatedPtrField< ::Log >&
      msgs() const;

  // @@protoc_insertion_point(class_scope:Logs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Log > msgs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_5fparsian_5fsimurosot_5fdebugs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Color

// float r = 1;
inline void Color::clear_r() {
  r_ = 0;
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:Color.r)
  return r_;
}
inline void Color::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:Color.r)
}

// float g = 2;
inline void Color::clear_g() {
  g_ = 0;
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:Color.g)
  return g_;
}
inline void Color::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:Color.g)
}

// float b = 3;
inline void Color::clear_b() {
  b_ = 0;
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:Color.b)
  return b_;
}
inline void Color::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:Color.b)
}

// float a = 4;
inline void Color::clear_a() {
  a_ = 0;
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:Color.a)
  return a_;
}
inline void Color::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:Color.a)
}

// -------------------------------------------------------------------

// Vec2

// float x = 1;
inline void Vec2::clear_x() {
  x_ = 0;
}
inline float Vec2::x() const {
  // @@protoc_insertion_point(field_get:Vec2.x)
  return x_;
}
inline void Vec2::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Vec2.x)
}

// float y = 2;
inline void Vec2::clear_y() {
  y_ = 0;
}
inline float Vec2::y() const {
  // @@protoc_insertion_point(field_get:Vec2.y)
  return y_;
}
inline void Vec2::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Vec2.y)
}

// -------------------------------------------------------------------

// Vec2D

// float x = 1;
inline void Vec2D::clear_x() {
  x_ = 0;
}
inline float Vec2D::x() const {
  // @@protoc_insertion_point(field_get:Vec2D.x)
  return x_;
}
inline void Vec2D::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Vec2D.x)
}

// float y = 2;
inline void Vec2D::clear_y() {
  y_ = 0;
}
inline float Vec2D::y() const {
  // @@protoc_insertion_point(field_get:Vec2D.y)
  return y_;
}
inline void Vec2D::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Vec2D.y)
}

// .Color color = 3;
inline bool Vec2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Vec2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Vec2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Vec2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Vec2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Vec2D::release_color() {
  // @@protoc_insertion_point(field_release:Vec2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Vec2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Vec2D.color)
  return color_;
}
inline void Vec2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Vec2D.color)
}

// -------------------------------------------------------------------

// Cir2D

// .Vec2 center = 1;
inline bool Cir2D::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline void Cir2D::clear_center() {
  if (GetArenaNoVirtual() == NULL && center_ != NULL) {
    delete center_;
  }
  center_ = NULL;
}
inline const ::Vec2& Cir2D::_internal_center() const {
  return *center_;
}
inline const ::Vec2& Cir2D::center() const {
  const ::Vec2* p = center_;
  // @@protoc_insertion_point(field_get:Cir2D.center)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Cir2D::release_center() {
  // @@protoc_insertion_point(field_release:Cir2D.center)
  
  ::Vec2* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::Vec2* Cir2D::mutable_center() {
  
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Cir2D.center)
  return center_;
}
inline void Cir2D::set_allocated_center(::Vec2* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:Cir2D.center)
}

// float startAngle = 2;
inline void Cir2D::clear_startangle() {
  startangle_ = 0;
}
inline float Cir2D::startangle() const {
  // @@protoc_insertion_point(field_get:Cir2D.startAngle)
  return startangle_;
}
inline void Cir2D::set_startangle(float value) {
  
  startangle_ = value;
  // @@protoc_insertion_point(field_set:Cir2D.startAngle)
}

// float endAngle = 3;
inline void Cir2D::clear_endangle() {
  endangle_ = 0;
}
inline float Cir2D::endangle() const {
  // @@protoc_insertion_point(field_get:Cir2D.endAngle)
  return endangle_;
}
inline void Cir2D::set_endangle(float value) {
  
  endangle_ = value;
  // @@protoc_insertion_point(field_set:Cir2D.endAngle)
}

// float radius = 4;
inline void Cir2D::clear_radius() {
  radius_ = 0;
}
inline float Cir2D::radius() const {
  // @@protoc_insertion_point(field_get:Cir2D.radius)
  return radius_;
}
inline void Cir2D::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:Cir2D.radius)
}

// bool fill = 5;
inline void Cir2D::clear_fill() {
  fill_ = false;
}
inline bool Cir2D::fill() const {
  // @@protoc_insertion_point(field_get:Cir2D.fill)
  return fill_;
}
inline void Cir2D::set_fill(bool value) {
  
  fill_ = value;
  // @@protoc_insertion_point(field_set:Cir2D.fill)
}

// .Color color = 6;
inline bool Cir2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Cir2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Cir2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Cir2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Cir2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Cir2D::release_color() {
  // @@protoc_insertion_point(field_release:Cir2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Cir2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Cir2D.color)
  return color_;
}
inline void Cir2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Cir2D.color)
}

// -------------------------------------------------------------------

// Seg2D

// .Vec2 origin = 1;
inline bool Seg2D::has_origin() const {
  return this != internal_default_instance() && origin_ != NULL;
}
inline void Seg2D::clear_origin() {
  if (GetArenaNoVirtual() == NULL && origin_ != NULL) {
    delete origin_;
  }
  origin_ = NULL;
}
inline const ::Vec2& Seg2D::_internal_origin() const {
  return *origin_;
}
inline const ::Vec2& Seg2D::origin() const {
  const ::Vec2* p = origin_;
  // @@protoc_insertion_point(field_get:Seg2D.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Seg2D::release_origin() {
  // @@protoc_insertion_point(field_release:Seg2D.origin)
  
  ::Vec2* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::Vec2* Seg2D::mutable_origin() {
  
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Seg2D.origin)
  return origin_;
}
inline void Seg2D::set_allocated_origin(::Vec2* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete origin_;
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.origin)
}

// .Vec2 terminal = 2;
inline bool Seg2D::has_terminal() const {
  return this != internal_default_instance() && terminal_ != NULL;
}
inline void Seg2D::clear_terminal() {
  if (GetArenaNoVirtual() == NULL && terminal_ != NULL) {
    delete terminal_;
  }
  terminal_ = NULL;
}
inline const ::Vec2& Seg2D::_internal_terminal() const {
  return *terminal_;
}
inline const ::Vec2& Seg2D::terminal() const {
  const ::Vec2* p = terminal_;
  // @@protoc_insertion_point(field_get:Seg2D.terminal)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Seg2D::release_terminal() {
  // @@protoc_insertion_point(field_release:Seg2D.terminal)
  
  ::Vec2* temp = terminal_;
  terminal_ = NULL;
  return temp;
}
inline ::Vec2* Seg2D::mutable_terminal() {
  
  if (terminal_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    terminal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Seg2D.terminal)
  return terminal_;
}
inline void Seg2D::set_allocated_terminal(::Vec2* terminal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete terminal_;
  }
  if (terminal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      terminal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    
  } else {
    
  }
  terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.terminal)
}

// .Color color = 3;
inline bool Seg2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Seg2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Seg2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Seg2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Seg2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Seg2D::release_color() {
  // @@protoc_insertion_point(field_release:Seg2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Seg2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Seg2D.color)
  return color_;
}
inline void Seg2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Seg2D.color)
}

// -------------------------------------------------------------------

// Rec2D

// .Vec2 topLeft = 1;
inline bool Rec2D::has_topleft() const {
  return this != internal_default_instance() && topleft_ != NULL;
}
inline void Rec2D::clear_topleft() {
  if (GetArenaNoVirtual() == NULL && topleft_ != NULL) {
    delete topleft_;
  }
  topleft_ = NULL;
}
inline const ::Vec2& Rec2D::_internal_topleft() const {
  return *topleft_;
}
inline const ::Vec2& Rec2D::topleft() const {
  const ::Vec2* p = topleft_;
  // @@protoc_insertion_point(field_get:Rec2D.topLeft)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Rec2D::release_topleft() {
  // @@protoc_insertion_point(field_release:Rec2D.topLeft)
  
  ::Vec2* temp = topleft_;
  topleft_ = NULL;
  return temp;
}
inline ::Vec2* Rec2D::mutable_topleft() {
  
  if (topleft_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    topleft_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rec2D.topLeft)
  return topleft_;
}
inline void Rec2D::set_allocated_topleft(::Vec2* topleft) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete topleft_;
  }
  if (topleft) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      topleft = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, topleft, submessage_arena);
    }
    
  } else {
    
  }
  topleft_ = topleft;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.topLeft)
}

// .Vec2 BotRight = 2;
inline bool Rec2D::has_botright() const {
  return this != internal_default_instance() && botright_ != NULL;
}
inline void Rec2D::clear_botright() {
  if (GetArenaNoVirtual() == NULL && botright_ != NULL) {
    delete botright_;
  }
  botright_ = NULL;
}
inline const ::Vec2& Rec2D::_internal_botright() const {
  return *botright_;
}
inline const ::Vec2& Rec2D::botright() const {
  const ::Vec2* p = botright_;
  // @@protoc_insertion_point(field_get:Rec2D.BotRight)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Rec2D::release_botright() {
  // @@protoc_insertion_point(field_release:Rec2D.BotRight)
  
  ::Vec2* temp = botright_;
  botright_ = NULL;
  return temp;
}
inline ::Vec2* Rec2D::mutable_botright() {
  
  if (botright_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    botright_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rec2D.BotRight)
  return botright_;
}
inline void Rec2D::set_allocated_botright(::Vec2* botright) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete botright_;
  }
  if (botright) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      botright = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, botright, submessage_arena);
    }
    
  } else {
    
  }
  botright_ = botright;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.BotRight)
}

// .Color color = 3;
inline bool Rec2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Rec2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Rec2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Rec2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Rec2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Rec2D::release_color() {
  // @@protoc_insertion_point(field_release:Rec2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Rec2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rec2D.color)
  return color_;
}
inline void Rec2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Rec2D.color)
}

// bool fill = 4;
inline void Rec2D::clear_fill() {
  fill_ = false;
}
inline bool Rec2D::fill() const {
  // @@protoc_insertion_point(field_get:Rec2D.fill)
  return fill_;
}
inline void Rec2D::set_fill(bool value) {
  
  fill_ = value;
  // @@protoc_insertion_point(field_set:Rec2D.fill)
}

// -------------------------------------------------------------------

// Tex2D

// .Vec2 pos = 1;
inline bool Tex2D::has_pos() const {
  return this != internal_default_instance() && pos_ != NULL;
}
inline void Tex2D::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) {
    delete pos_;
  }
  pos_ = NULL;
}
inline const ::Vec2& Tex2D::_internal_pos() const {
  return *pos_;
}
inline const ::Vec2& Tex2D::pos() const {
  const ::Vec2* p = pos_;
  // @@protoc_insertion_point(field_get:Tex2D.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::Vec2*>(
      &::_Vec2_default_instance_);
}
inline ::Vec2* Tex2D::release_pos() {
  // @@protoc_insertion_point(field_release:Tex2D.pos)
  
  ::Vec2* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::Vec2* Tex2D::mutable_pos() {
  
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::Vec2>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Tex2D.pos)
  return pos_;
}
inline void Tex2D::set_allocated_pos(::Vec2* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Tex2D.pos)
}

// float size = 2;
inline void Tex2D::clear_size() {
  size_ = 0;
}
inline float Tex2D::size() const {
  // @@protoc_insertion_point(field_get:Tex2D.size)
  return size_;
}
inline void Tex2D::set_size(float value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Tex2D.size)
}

// .Color color = 3;
inline bool Tex2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Tex2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Tex2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Tex2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Tex2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Tex2D::release_color() {
  // @@protoc_insertion_point(field_release:Tex2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Tex2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Tex2D.color)
  return color_;
}
inline void Tex2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Tex2D.color)
}

// string data = 4;
inline void Tex2D::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tex2D::data() const {
  // @@protoc_insertion_point(field_get:Tex2D.data)
  return data_.GetNoArena();
}
inline void Tex2D::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Tex2D.data)
}
#if LANG_CXX11
inline void Tex2D::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Tex2D.data)
}
#endif
inline void Tex2D::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Tex2D.data)
}
inline void Tex2D::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Tex2D.data)
}
inline ::std::string* Tex2D::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Tex2D.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tex2D::release_data() {
  // @@protoc_insertion_point(field_release:Tex2D.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tex2D::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Tex2D.data)
}

// -------------------------------------------------------------------

// Pol2D

// repeated .Vec2 vectors = 1;
inline int Pol2D::vectors_size() const {
  return vectors_.size();
}
inline void Pol2D::clear_vectors() {
  vectors_.Clear();
}
inline ::Vec2* Pol2D::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:Pol2D.vectors)
  return vectors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Vec2 >*
Pol2D::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:Pol2D.vectors)
  return &vectors_;
}
inline const ::Vec2& Pol2D::vectors(int index) const {
  // @@protoc_insertion_point(field_get:Pol2D.vectors)
  return vectors_.Get(index);
}
inline ::Vec2* Pol2D::add_vectors() {
  // @@protoc_insertion_point(field_add:Pol2D.vectors)
  return vectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Vec2 >&
Pol2D::vectors() const {
  // @@protoc_insertion_point(field_list:Pol2D.vectors)
  return vectors_;
}

// .Color color = 2;
inline bool Pol2D::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Pol2D::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::Color& Pol2D::_internal_color() const {
  return *color_;
}
inline const ::Color& Pol2D::color() const {
  const ::Color* p = color_;
  // @@protoc_insertion_point(field_get:Pol2D.color)
  return p != NULL ? *p : *reinterpret_cast<const ::Color*>(
      &::_Color_default_instance_);
}
inline ::Color* Pol2D::release_color() {
  // @@protoc_insertion_point(field_release:Pol2D.color)
  
  ::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::Color* Pol2D::mutable_color() {
  
  if (color_ == NULL) {
    auto* p = CreateMaybeMessage<::Color>(GetArenaNoVirtual());
    color_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pol2D.color)
  return color_;
}
inline void Pol2D::set_allocated_color(::Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:Pol2D.color)
}

// bool fill = 3;
inline void Pol2D::clear_fill() {
  fill_ = false;
}
inline bool Pol2D::fill() const {
  // @@protoc_insertion_point(field_get:Pol2D.fill)
  return fill_;
}
inline void Pol2D::set_fill(bool value) {
  
  fill_ = value;
  // @@protoc_insertion_point(field_set:Pol2D.fill)
}

// -------------------------------------------------------------------

// Draws

// repeated .Vec2D vectors = 1;
inline int Draws::vectors_size() const {
  return vectors_.size();
}
inline void Draws::clear_vectors() {
  vectors_.Clear();
}
inline ::Vec2D* Draws::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.vectors)
  return vectors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Vec2D >*
Draws::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:Draws.vectors)
  return &vectors_;
}
inline const ::Vec2D& Draws::vectors(int index) const {
  // @@protoc_insertion_point(field_get:Draws.vectors)
  return vectors_.Get(index);
}
inline ::Vec2D* Draws::add_vectors() {
  // @@protoc_insertion_point(field_add:Draws.vectors)
  return vectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Vec2D >&
Draws::vectors() const {
  // @@protoc_insertion_point(field_list:Draws.vectors)
  return vectors_;
}

// repeated .Cir2D circles = 2;
inline int Draws::circles_size() const {
  return circles_.size();
}
inline void Draws::clear_circles() {
  circles_.Clear();
}
inline ::Cir2D* Draws::mutable_circles(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.circles)
  return circles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Cir2D >*
Draws::mutable_circles() {
  // @@protoc_insertion_point(field_mutable_list:Draws.circles)
  return &circles_;
}
inline const ::Cir2D& Draws::circles(int index) const {
  // @@protoc_insertion_point(field_get:Draws.circles)
  return circles_.Get(index);
}
inline ::Cir2D* Draws::add_circles() {
  // @@protoc_insertion_point(field_add:Draws.circles)
  return circles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cir2D >&
Draws::circles() const {
  // @@protoc_insertion_point(field_list:Draws.circles)
  return circles_;
}

// repeated .Seg2D segments = 3;
inline int Draws::segments_size() const {
  return segments_.size();
}
inline void Draws::clear_segments() {
  segments_.Clear();
}
inline ::Seg2D* Draws::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.segments)
  return segments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Seg2D >*
Draws::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:Draws.segments)
  return &segments_;
}
inline const ::Seg2D& Draws::segments(int index) const {
  // @@protoc_insertion_point(field_get:Draws.segments)
  return segments_.Get(index);
}
inline ::Seg2D* Draws::add_segments() {
  // @@protoc_insertion_point(field_add:Draws.segments)
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Seg2D >&
Draws::segments() const {
  // @@protoc_insertion_point(field_list:Draws.segments)
  return segments_;
}

// repeated .Rec2D rects = 4;
inline int Draws::rects_size() const {
  return rects_.size();
}
inline void Draws::clear_rects() {
  rects_.Clear();
}
inline ::Rec2D* Draws::mutable_rects(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.rects)
  return rects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Rec2D >*
Draws::mutable_rects() {
  // @@protoc_insertion_point(field_mutable_list:Draws.rects)
  return &rects_;
}
inline const ::Rec2D& Draws::rects(int index) const {
  // @@protoc_insertion_point(field_get:Draws.rects)
  return rects_.Get(index);
}
inline ::Rec2D* Draws::add_rects() {
  // @@protoc_insertion_point(field_add:Draws.rects)
  return rects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Rec2D >&
Draws::rects() const {
  // @@protoc_insertion_point(field_list:Draws.rects)
  return rects_;
}

// repeated .Pol2D polygons = 5;
inline int Draws::polygons_size() const {
  return polygons_.size();
}
inline void Draws::clear_polygons() {
  polygons_.Clear();
}
inline ::Pol2D* Draws::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.polygons)
  return polygons_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pol2D >*
Draws::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:Draws.polygons)
  return &polygons_;
}
inline const ::Pol2D& Draws::polygons(int index) const {
  // @@protoc_insertion_point(field_get:Draws.polygons)
  return polygons_.Get(index);
}
inline ::Pol2D* Draws::add_polygons() {
  // @@protoc_insertion_point(field_add:Draws.polygons)
  return polygons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pol2D >&
Draws::polygons() const {
  // @@protoc_insertion_point(field_list:Draws.polygons)
  return polygons_;
}

// repeated .Tex2D texts = 6;
inline int Draws::texts_size() const {
  return texts_.size();
}
inline void Draws::clear_texts() {
  texts_.Clear();
}
inline ::Tex2D* Draws::mutable_texts(int index) {
  // @@protoc_insertion_point(field_mutable:Draws.texts)
  return texts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Tex2D >*
Draws::mutable_texts() {
  // @@protoc_insertion_point(field_mutable_list:Draws.texts)
  return &texts_;
}
inline const ::Tex2D& Draws::texts(int index) const {
  // @@protoc_insertion_point(field_get:Draws.texts)
  return texts_.Get(index);
}
inline ::Tex2D* Draws::add_texts() {
  // @@protoc_insertion_point(field_add:Draws.texts)
  return texts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Tex2D >&
Draws::texts() const {
  // @@protoc_insertion_point(field_list:Draws.texts)
  return texts_;
}

// -------------------------------------------------------------------

// Log

// .LogLevel level = 1;
inline void Log::clear_level() {
  level_ = 0;
}
inline ::LogLevel Log::level() const {
  // @@protoc_insertion_point(field_get:Log.level)
  return static_cast< ::LogLevel >(level_);
}
inline void Log::set_level(::LogLevel value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:Log.level)
}

// string msg = 2;
inline void Log::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log::msg() const {
  // @@protoc_insertion_point(field_get:Log.msg)
  return msg_.GetNoArena();
}
inline void Log::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Log.msg)
}
#if LANG_CXX11
inline void Log::set_msg(::std::string&& value) {
  
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.msg)
}
#endif
inline void Log::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.msg)
}
inline void Log::set_msg(const char* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.msg)
}
inline ::std::string* Log::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:Log.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_msg() {
  // @@protoc_insertion_point(field_release:Log.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Log.msg)
}

// string file = 3;
inline void Log::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log::file() const {
  // @@protoc_insertion_point(field_get:Log.file)
  return file_.GetNoArena();
}
inline void Log::set_file(const ::std::string& value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Log.file)
}
#if LANG_CXX11
inline void Log::set_file(::std::string&& value) {
  
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.file)
}
#endif
inline void Log::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.file)
}
inline void Log::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.file)
}
inline ::std::string* Log::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:Log.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_file() {
  // @@protoc_insertion_point(field_release:Log.file)
  
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:Log.file)
}

// string function = 4;
inline void Log::clear_function() {
  function_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log::function() const {
  // @@protoc_insertion_point(field_get:Log.function)
  return function_.GetNoArena();
}
inline void Log::set_function(const ::std::string& value) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Log.function)
}
#if LANG_CXX11
inline void Log::set_function(::std::string&& value) {
  
  function_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.function)
}
#endif
inline void Log::set_function(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.function)
}
inline void Log::set_function(const char* value, size_t size) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.function)
}
inline ::std::string* Log::mutable_function() {
  
  // @@protoc_insertion_point(field_mutable:Log.function)
  return function_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_function() {
  // @@protoc_insertion_point(field_release:Log.function)
  
  return function_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_function(::std::string* function) {
  if (function != NULL) {
    
  } else {
    
  }
  function_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:Log.function)
}

// string line = 5;
inline void Log::clear_line() {
  line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Log::line() const {
  // @@protoc_insertion_point(field_get:Log.line)
  return line_.GetNoArena();
}
inline void Log::set_line(const ::std::string& value) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Log.line)
}
#if LANG_CXX11
inline void Log::set_line(::std::string&& value) {
  
  line_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Log.line)
}
#endif
inline void Log::set_line(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Log.line)
}
inline void Log::set_line(const char* value, size_t size) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Log.line)
}
inline ::std::string* Log::mutable_line() {
  
  // @@protoc_insertion_point(field_mutable:Log.line)
  return line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Log::release_line() {
  // @@protoc_insertion_point(field_release:Log.line)
  
  return line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Log::set_allocated_line(::std::string* line) {
  if (line != NULL) {
    
  } else {
    
  }
  line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), line);
  // @@protoc_insertion_point(field_set_allocated:Log.line)
}

// -------------------------------------------------------------------

// Logs

// repeated .Log msgs = 1;
inline int Logs::msgs_size() const {
  return msgs_.size();
}
inline void Logs::clear_msgs() {
  msgs_.Clear();
}
inline ::Log* Logs::mutable_msgs(int index) {
  // @@protoc_insertion_point(field_mutable:Logs.msgs)
  return msgs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Log >*
Logs::mutable_msgs() {
  // @@protoc_insertion_point(field_mutable_list:Logs.msgs)
  return &msgs_;
}
inline const ::Log& Logs::msgs(int index) const {
  // @@protoc_insertion_point(field_get:Logs.msgs)
  return msgs_.Get(index);
}
inline ::Log* Logs::add_msgs() {
  // @@protoc_insertion_point(field_add:Logs.msgs)
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Log >&
Logs::msgs() const {
  // @@protoc_insertion_point(field_list:Logs.msgs)
  return msgs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LogLevel>() {
  return ::LogLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_5fparsian_5fsimurosot_5fdebugs_2eproto
